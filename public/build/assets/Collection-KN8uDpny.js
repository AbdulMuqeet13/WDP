import{O as $,K as b,p,g as A,N as S,ae as _,af as j,H as k,ag as R,f as g,n as D,U as F,d as w,B as L,G as I,C as B,ah as K}from"./app-DUflAWwO.js";import{B as z,o as W,C as q,g as U,S as T}from"./createLucideIcon-BRklbVbG.js";function H(t,e){const r=typeof t=="string"&&!e?`${t}Context`:e,a=Symbol(r);return[o=>{const u=$(a,o);if(u||u===null)return u;throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},o=>(b(a,o),o)]}const[V]=H("ConfigProvider");function te(t){const e=V({dir:p("ltr")});return A(()=>t?.value||e.dir?.value||"ltr")}function G(t){const e=S(),r=e?.type.emits,a={};return r?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),r?.forEach(n=>{a[_(j(n))]=(...l)=>t(n,...l)}),a}function Y(t){const e=S(),r=Object.keys(e?.type.props??{}).reduce((n,l)=>{const o=(e?.type.props[l]).default;return o!==void 0&&(n[l]=o),n},{}),a=k(t);return A(()=>{const n={},l=e?.vnode.props??{};return Object.keys(l).forEach(o=>{n[j(o)]=l[o]}),Object.keys({...r,...n}).reduce((o,u)=>(a.value[u]!==void 0&&(o[u]=a.value[u]),o),{})})}function ne(t,e){const r=Y(t),a=e?G(e):{};return A(()=>({...r.value,...a}))}function oe(t,e="reka"){return`${e}-${R?.()}`}function J(t,e){const r=p(t);function a(l){return e[r.value][l]??r.value}return{state:r,dispatch:l=>{r.value=a(l)}}}function Q(t,e){const r=p({}),a=p("none"),n=p(t),l=t.value?"mounted":"unmounted";let o;const u=e.value?.ownerDocument.defaultView??z,{state:d,dispatch:c}=J(l,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),i=s=>{if(W){const f=new CustomEvent(s,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(f)}};g(t,async(s,f)=>{const C=f!==s;if(await D(),C){const P=a.value,N=M(e.value);s?(c("MOUNT"),i("enter"),N==="none"&&i("after-enter")):N==="none"||N==="undefined"||r.value?.display==="none"?(c("UNMOUNT"),i("leave"),i("after-leave")):f&&P!==N?(c("ANIMATION_OUT"),i("leave")):(c("UNMOUNT"),i("after-leave"))}},{immediate:!0});const m=s=>{const f=M(e.value),C=f.includes(CSS.escape(s.animationName)),P=d.value==="mounted"?"enter":"leave";if(s.target===e.value&&C&&(i(`after-${P}`),c("ANIMATION_END"),!n.value)){const N=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",o=u?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=N)})}s.target===e.value&&f==="none"&&c("ANIMATION_END")},v=s=>{s.target===e.value&&(a.value=M(e.value))},h=g(e,(s,f)=>{s?(r.value=getComputedStyle(s),s.addEventListener("animationstart",v),s.addEventListener("animationcancel",m),s.addEventListener("animationend",m)):(c("ANIMATION_END"),o!==void 0&&u?.clearTimeout(o),f?.removeEventListener("animationstart",v),f?.removeEventListener("animationcancel",m),f?.removeEventListener("animationend",m))},{immediate:!0}),y=g(d,()=>{const s=M(e.value);a.value=d.value==="mounted"?s:"none"});return F(()=>{h(),y()}),{isPresent:A(()=>["mounted","unmountSuspended"].includes(d.value))}}function M(t){return t&&getComputedStyle(t).animationName||"none"}var ae=w({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:r}){const{present:a,forceMount:n}=L(t),l=p(),{isPresent:o}=Q(a,l);r({present:o});let u=e.default({present:o.value});u=q(u||[]);const d=S();if(u&&u?.length>1){const c=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${c}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(i=>`  - ${i}`).join(`
`)].join(`
`))}return()=>n.value||a.value||o.value?I(e.default({present:o.value})[0],{ref:c=>{const i=U(c);return typeof i?.hasAttribute>"u"||(i?.hasAttribute("data-reka-popper-content-wrapper")?l.value=i.firstElementChild:l.value=i),i}}):null}});function O(){const t=p(),e=A(()=>["#text","#comment"].includes(t.value?.$el.nodeName)?t.value?.$el.nextElementSibling:U(t));return{primitiveElement:t,currentElement:e}}const x="data-reka-collection-item";function ie(t={}){const{key:e="",isProvider:r=!1}=t,a=`${e}CollectionProvider`;let n;if(r){const i=p(new Map);n={collectionRef:p(),itemMap:i},b(a,n)}else n=$(a);const l=(i=!1)=>{const m=n.collectionRef.value;if(!m)return[];const v=Array.from(m.querySelectorAll(`[${x}]`)),y=Array.from(n.itemMap.value.values()).sort((E,s)=>v.indexOf(E.ref)-v.indexOf(s.ref));return i?y:y.filter(E=>E.ref.dataset.disabled!=="")},o=w({name:"CollectionSlot",setup(i,{slots:m}){const{primitiveElement:v,currentElement:h}=O();return g(h,()=>{n.collectionRef.value=h.value}),()=>I(T,{ref:v},m)}}),u=w({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(i,{slots:m,attrs:v}){const{primitiveElement:h,currentElement:y}=O();return B(E=>{if(y.value){const s=K(y.value);n.itemMap.value.set(s,{ref:y.value,value:i.value}),E(()=>n.itemMap.value.delete(s))}}),()=>I(T,{...v,[x]:"",ref:h},m)}}),d=A(()=>Array.from(n.itemMap.value.values())),c=A(()=>n.itemMap.value.size);return{getItems:l,reactiveItems:d,itemMapSize:c,CollectionSlot:o,CollectionItem:u}}export{ae as P,te as a,oe as b,H as c,Y as d,ne as e,G as f,O as g,V as i,ie as u};
