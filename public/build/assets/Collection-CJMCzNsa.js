import{x as $,s as b,r as p,h as A,f as S,ae as U,i as j,af as _,ag as k,l as g,y as D,q as F,d as C,t as L,R as I,m as q,ah as z}from"./app-D-iDICra.js";import{B,p as K,C as W,i as R,S as T}from"./createLucideIcon-BXrbf_aG.js";function V(t,e){const r=typeof t=="string"&&!e?`${t}Context`:e,a=Symbol(r);return[o=>{const u=$(a,o);if(u||u===null)return u;throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},o=>(b(a,o),o)]}const[H]=V("ConfigProvider");function te(t){const e=H({dir:p("ltr")});return A(()=>t?.value||e.dir?.value||"ltr")}function Y(t){const e=S(),r=e?.type.emits,a={};return r?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),r?.forEach(n=>{a[U(j(n))]=(...l)=>t(n,...l)}),a}function G(t){const e=S(),r=Object.keys(e?.type.props??{}).reduce((n,l)=>{const o=(e?.type.props[l]).default;return o!==void 0&&(n[l]=o),n},{}),a=_(t);return A(()=>{const n={},l=e?.vnode.props??{};return Object.keys(l).forEach(o=>{n[j(o)]=l[o]}),Object.keys({...r,...n}).reduce((o,u)=>(a.value[u]!==void 0&&(o[u]=a.value[u]),o),{})})}function ne(t,e){const r=G(t),a=e?Y(e):{};return A(()=>({...r.value,...a}))}function oe(t,e="reka"){return`${e}-${k?.()}`}function J(t,e){const r=p(t);function a(l){return e[r.value][l]??r.value}return{state:r,dispatch:l=>{r.value=a(l)}}}function Q(t,e){const r=p({}),a=p("none"),n=p(t),l=t.value?"mounted":"unmounted";let o;const u=e.value?.ownerDocument.defaultView??B,{state:d,dispatch:c}=J(l,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),i=s=>{if(K){const f=new CustomEvent(s,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(f)}};g(t,async(s,f)=>{const P=f!==s;if(await D(),P){const w=a.value,N=M(e.value);s?(c("MOUNT"),i("enter"),N==="none"&&i("after-enter")):N==="none"||N==="undefined"||r.value?.display==="none"?(c("UNMOUNT"),i("leave"),i("after-leave")):f&&w!==N?(c("ANIMATION_OUT"),i("leave")):(c("UNMOUNT"),i("after-leave"))}},{immediate:!0});const m=s=>{const f=M(e.value),P=f.includes(CSS.escape(s.animationName)),w=d.value==="mounted"?"enter":"leave";if(s.target===e.value&&P&&(i(`after-${w}`),c("ANIMATION_END"),!n.value)){const N=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",o=u?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=N)})}s.target===e.value&&f==="none"&&c("ANIMATION_END")},v=s=>{s.target===e.value&&(a.value=M(e.value))},h=g(e,(s,f)=>{s?(r.value=getComputedStyle(s),s.addEventListener("animationstart",v),s.addEventListener("animationcancel",m),s.addEventListener("animationend",m)):(c("ANIMATION_END"),o!==void 0&&u?.clearTimeout(o),f?.removeEventListener("animationstart",v),f?.removeEventListener("animationcancel",m),f?.removeEventListener("animationend",m))},{immediate:!0}),y=g(d,()=>{const s=M(e.value);a.value=d.value==="mounted"?s:"none"});return F(()=>{h(),y()}),{isPresent:A(()=>["mounted","unmountSuspended"].includes(d.value))}}function M(t){return t&&getComputedStyle(t).animationName||"none"}var ae=C({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:r}){const{present:a,forceMount:n}=L(t),l=p(),{isPresent:o}=Q(a,l);r({present:o});let u=e.default({present:o.value});u=W(u||[]);const d=S();if(u&&u?.length>1){const c=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${c}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(i=>`  - ${i}`).join(`
`)].join(`
`))}return()=>n.value||a.value||o.value?I(e.default({present:o.value})[0],{ref:c=>{const i=R(c);return typeof i?.hasAttribute>"u"||(i?.hasAttribute("data-reka-popper-content-wrapper")?l.value=i.firstElementChild:l.value=i),i}}):null}});function x(){const t=p(),e=A(()=>["#text","#comment"].includes(t.value?.$el.nodeName)?t.value?.$el.nextElementSibling:R(t));return{primitiveElement:t,currentElement:e}}const O="data-reka-collection-item";function ie(t={}){const{key:e="",isProvider:r=!1}=t,a=`${e}CollectionProvider`;let n;if(r){const i=p(new Map);n={collectionRef:p(),itemMap:i},b(a,n)}else n=$(a);const l=(i=!1)=>{const m=n.collectionRef.value;if(!m)return[];const v=Array.from(m.querySelectorAll(`[${O}]`)),y=Array.from(n.itemMap.value.values()).sort((E,s)=>v.indexOf(E.ref)-v.indexOf(s.ref));return i?y:y.filter(E=>E.ref.dataset.disabled!=="")},o=C({name:"CollectionSlot",setup(i,{slots:m}){const{primitiveElement:v,currentElement:h}=x();return g(h,()=>{n.collectionRef.value=h.value}),()=>I(T,{ref:v},m)}}),u=C({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(i,{slots:m,attrs:v}){const{primitiveElement:h,currentElement:y}=x();return q(E=>{if(y.value){const s=z(y.value);n.itemMap.value.set(s,{ref:y.value,value:i.value}),E(()=>n.itemMap.value.delete(s))}}),()=>I(T,{...v,[O]:"",ref:h},m)}}),d=A(()=>Array.from(n.itemMap.value.values())),c=A(()=>n.itemMap.value.size);return{getItems:l,reactiveItems:d,itemMapSize:c,CollectionSlot:o,CollectionItem:u}}export{ae as P,te as a,oe as b,V as c,G as d,ne as e,x as f,Y as g,H as i,ie as u};
