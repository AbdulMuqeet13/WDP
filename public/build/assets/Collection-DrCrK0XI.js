import{aa as x,ab as $,k as p,g as A,ac as S,ad as U,ae as j,af as _,ag as R,f as g,n as D,B as F,d as C,q as L,O as I,s as B,ah as q}from"./app-Bm4O4usw.js";import{B as z,o as K,C as W,b as k,S as T}from"./createLucideIcon-BIZlk_4d.js";function V(t,e){const r=typeof t=="string"&&!e?`${t}Context`:e,o=Symbol(r);return[a=>{const u=x(o,a);if(u||u===null)return u;throw new Error(`Injection \`${o.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},a=>($(o,a),a)]}const[H]=V("ConfigProvider");function te(t){const e=H({dir:p("ltr")});return A(()=>t?.value||e.dir?.value||"ltr")}function Y(t){const e=S(),r=e?.type.emits,o={};return r?.length||console.warn(`No emitted event found. Please check component: ${e?.type.__name}`),r?.forEach(n=>{o[U(j(n))]=(...l)=>t(n,...l)}),o}function G(t){const e=S(),r=Object.keys(e?.type.props??{}).reduce((n,l)=>{const a=(e?.type.props[l]).default;return a!==void 0&&(n[l]=a),n},{}),o=_(t);return A(()=>{const n={},l=e?.vnode.props??{};return Object.keys(l).forEach(a=>{n[j(a)]=l[a]}),Object.keys({...r,...n}).reduce((a,u)=>(o.value[u]!==void 0&&(a[u]=o.value[u]),a),{})})}function ne(t,e){const r=G(t),o=e?Y(e):{};return A(()=>({...r.value,...o}))}function ae(t,e="reka"){return`${e}-${R?.()}`}function J(t,e){const r=p(t);function o(l){return e[r.value][l]??r.value}return{state:r,dispatch:l=>{r.value=o(l)}}}function Q(t,e){const r=p({}),o=p("none"),n=p(t),l=t.value?"mounted":"unmounted";let a;const u=e.value?.ownerDocument.defaultView??z,{state:d,dispatch:c}=J(l,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),i=s=>{if(K){const f=new CustomEvent(s,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(f)}};g(t,async(s,f)=>{const P=f!==s;if(await D(),P){const w=o.value,N=M(e.value);s?(c("MOUNT"),i("enter"),N==="none"&&i("after-enter")):N==="none"||N==="undefined"||r.value?.display==="none"?(c("UNMOUNT"),i("leave"),i("after-leave")):f&&w!==N?(c("ANIMATION_OUT"),i("leave")):(c("UNMOUNT"),i("after-leave"))}},{immediate:!0});const m=s=>{const f=M(e.value),P=f.includes(CSS.escape(s.animationName)),w=d.value==="mounted"?"enter":"leave";if(s.target===e.value&&P&&(i(`after-${w}`),c("ANIMATION_END"),!n.value)){const N=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",a=u?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=N)})}s.target===e.value&&f==="none"&&c("ANIMATION_END")},v=s=>{s.target===e.value&&(o.value=M(e.value))},h=g(e,(s,f)=>{s?(r.value=getComputedStyle(s),s.addEventListener("animationstart",v),s.addEventListener("animationcancel",m),s.addEventListener("animationend",m)):(c("ANIMATION_END"),a!==void 0&&u?.clearTimeout(a),f?.removeEventListener("animationstart",v),f?.removeEventListener("animationcancel",m),f?.removeEventListener("animationend",m))},{immediate:!0}),y=g(d,()=>{const s=M(e.value);o.value=d.value==="mounted"?s:"none"});return F(()=>{h(),y()}),{isPresent:A(()=>["mounted","unmountSuspended"].includes(d.value))}}function M(t){return t&&getComputedStyle(t).animationName||"none"}var oe=C({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:r}){const{present:o,forceMount:n}=L(t),l=p(),{isPresent:a}=Q(o,l);r({present:a});let u=e.default({present:a.value});u=W(u||[]);const d=S();if(u&&u?.length>1){const c=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${c}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(i=>`  - ${i}`).join(`
`)].join(`
`))}return()=>n.value||o.value||a.value?I(e.default({present:a.value})[0],{ref:c=>{const i=k(c);return typeof i?.hasAttribute>"u"||(i?.hasAttribute("data-reka-popper-content-wrapper")?l.value=i.firstElementChild:l.value=i),i}}):null}});function O(){const t=p(),e=A(()=>["#text","#comment"].includes(t.value?.$el.nodeName)?t.value?.$el.nextElementSibling:k(t));return{primitiveElement:t,currentElement:e}}const b="data-reka-collection-item";function ie(t={}){const{key:e="",isProvider:r=!1}=t,o=`${e}CollectionProvider`;let n;if(r){const i=p(new Map);n={collectionRef:p(),itemMap:i},$(o,n)}else n=x(o);const l=(i=!1)=>{const m=n.collectionRef.value;if(!m)return[];const v=Array.from(m.querySelectorAll(`[${b}]`)),y=Array.from(n.itemMap.value.values()).sort((E,s)=>v.indexOf(E.ref)-v.indexOf(s.ref));return i?y:y.filter(E=>E.ref.dataset.disabled!=="")},a=C({name:"CollectionSlot",setup(i,{slots:m}){const{primitiveElement:v,currentElement:h}=O();return g(h,()=>{n.collectionRef.value=h.value}),()=>I(T,{ref:v},m)}}),u=C({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(i,{slots:m,attrs:v}){const{primitiveElement:h,currentElement:y}=O();return B(E=>{if(y.value){const s=q(y.value);n.itemMap.value.set(s,{ref:y.value,value:i.value}),E(()=>n.itemMap.value.delete(s))}}),()=>I(T,{...v,[b]:"",ref:h},m)}}),d=A(()=>Array.from(n.itemMap.value.values())),c=A(()=>n.itemMap.value.size);return{getItems:l,reactiveItems:d,itemMapSize:c,CollectionSlot:a,CollectionItem:u}}export{oe as P,te as a,G as b,V as c,ne as d,ae as e,O as f,Y as g,H as i,ie as u};
